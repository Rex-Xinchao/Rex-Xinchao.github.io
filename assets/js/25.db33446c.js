(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{385:function(t,a,e){"use strict";e.r(a);var v=e(42),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#什么是闭包"}},[t._v("什么是闭包")])]),e("li",[e("a",{attrs:{href:"#原型链"}},[t._v("原型链")])]),e("li",[e("a",{attrs:{href:"#深拷贝"}},[t._v("深拷贝")])]),e("li",[e("a",{attrs:{href:"#首屏优化的方案"}},[t._v("首屏优化的方案")])]),e("li",[e("a",{attrs:{href:"#元素居中的实现方案"}},[t._v("元素居中的实现方案")])]),e("li",[e("a",{attrs:{href:"#vue-生命周期"}},[t._v("vue 生命周期")])]),e("li",[e("a",{attrs:{href:"#vue-双向绑定原理"}},[t._v("vue 双向绑定原理")])]),e("li",[e("a",{attrs:{href:"#v-if-和-v-for-的优先级"}},[t._v("v-if 和 v-for 的优先级")])]),e("li",[e("a",{attrs:{href:"#vue-筛选器过滤多个参数"}},[t._v("vue 筛选器过滤多个参数")])]),e("li",[e("a",{attrs:{href:"#严格模式"}},[t._v("严格模式")])]),e("li",[e("a",{attrs:{href:"#冒泡排序"}},[t._v("冒泡排序")])])])]),e("p"),t._v(" "),e("h3",{attrs:{id:"什么是闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[t._v("#")]),t._v(" 什么是闭包")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("闭包就是能够读取其他函数内部变量的函数。")]),t._v(" "),e("li",[t._v("在 js 中那就是定义在函数内部的函数。")])])]),t._v(" "),e("h3",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("原型：函数 prototype 指向的对象就是原型（只有函数对象才有 prototype 属性）。")]),t._v(" "),e("li",[t._v("原型链：函数或对象的"),e("strong",[t._v("proto")]),t._v(" 指向创建它的构造函数的原型对象。")])])]),t._v(" "),e("h3",{attrs:{id:"深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[t._v("#")]),t._v(" 深拷贝")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("对象 A = 对象 B，因为对象 B 获取到的是对象 A 指向的是一个指针，A 和 B 的指针指向同一个存储空间。因此对象 B 对指针指向的值进行变更，同事会影响到对象 A。")]),t._v(" "),e("li",[t._v("深拷贝的实现方案： + obj = Object.assign({}, 目标对象) + obj = [...目标对象] //当前仅当目标对象只有一层 + obj = JSON.parse(JSON.stringify(目标对象)) 缺点：会忽略 undefined、symbol。不能序列化函数。不能解决循环引用的问题。 + let obj = {} for (let key in 目标对象) { obj[key] = 目标对象[key]} + 通过递归函数实现\n"),e("code",[t._v("function deepClone(target, map = new Map()) { function isObj(o) { return (typeof o === 'object' || typeof o === 'function') && o !== null; } if (isObj(target)) { let cloneTarget = Array.isArray(target) ? [] : {}; if (map.get(target)) { return map.get(target); } map.set(target, cloneTarget); for (const key in target) { cloneTarget[key] = deepClone(target[key], map); } return cloneTarget; } else { return target; } }")])])])]),t._v(" "),e("h3",{attrs:{id:"首屏优化的方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首屏优化的方案"}},[t._v("#")]),t._v(" 首屏优化的方案")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("雪碧图（减少请求数）")]),t._v(" "),e("li",[t._v("骨架屏")]),t._v(" "),e("li",[t._v("图片懒加载")]),t._v(" "),e("li",[t._v("CDN（通过 CDN 引入资源和三方库）")]),t._v(" "),e("li",[t._v("缓存（强缓存和协商缓存）")]),t._v(" "),e("li",[t._v("服务器渲染（有利于 SEO，减少浏览器的渲染压力）")]),t._v(" "),e("li",[t._v("vue-route 懒加载 （vue-route 的异步组件和 webpack 的代码分割）\n"),e("ul",[e("li",[t._v("const Foo = () => Promise.resolve({ /_ 组件定义对象 _/ })")]),t._v(" "),e("li",[t._v("import('./Foo.vue') // 返回 Promise")])])]),t._v(" "),e("li",[t._v("打包优化 + 使用 webpack-bundle-analyzer 进行分析 + 忽略不使用的引入 + 删除重复引入 + hash 缓存 + 代码分割 + 生产环境关闭")])])]),t._v(" "),e("h3",{attrs:{id:"元素居中的实现方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素居中的实现方案"}},[t._v("#")]),t._v(" 元素居中的实现方案")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("margin：0 auto")]),t._v(" "),e("li",[t._v("position：absolute; top/bottom/left/rigth: 0;")]),t._v(" "),e("li",[t._v("position：absolute; left: 50%; margin-left: -50%的元素宽度")]),t._v(" "),e("li",[t._v("display：flex; align-content: center(竖直|多行) align-items: center(竖直|单行) justify-content: center(水平)")]),t._v(" "),e("li",[t._v("display：grid; align-items: center(竖直|单行) justify-content: center(水平)")])])]),t._v(" "),e("h3",{attrs:{id:"vue-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[t._v("#")]),t._v(" vue 生命周期")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。")]),t._v(" "),e("li",[t._v("created：在实例创建完成后被立即调用。")]),t._v(" "),e("li",[t._v("beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。")]),t._v(" "),e("li",[t._v("mounted:虚拟 dom 生成后，并挂载到实例上去之后调用该钩子。")]),t._v(" "),e("li",[t._v("beforeUpdate:数据更新时调用，发生在虚拟 DOM 打补丁之前。")]),t._v(" "),e("li",[t._v("update:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。")])])]),t._v(" "),e("h3",{attrs:{id:"vue-双向绑定原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-双向绑定原理"}},[t._v("#")]),t._v(" vue 双向绑定原理")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("vue 的数据双向绑定是通过数据劫持和发布-订阅者功能来实现的，实现步骤：")]),t._v(" "),e("ul",[e("li",[t._v("实现一个监听者 Oberver 来劫持并监听所有的属性，一旦有属性发生变化就通知订阅者")]),t._v(" "),e("li",[t._v("实现一个订阅者 watcher 来接受属性变化的通知并执行相应的方法，从而更新视图")]),t._v(" "),e("li",[t._v("实现一个解析器 compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相对应的订阅者")])])]),t._v(" "),e("h3",{attrs:{id:"v-if-和-v-for-的优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-的优先级"}},[t._v("#")]),t._v(" v-if 和 v-for 的优先级")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("在 vue2.0 当中，v-if 和 v-for 可以并存在在一个 dom 上。")]),t._v(" "),e("li",[t._v("在 vue2.0 当中，v-for 优先级高，v-if 可以使用刀 v-for 的 key 值。")]),t._v(" "),e("li",[t._v("在 vue3.0 当中，v-if 和 v-for 已经不能并存在同一个 dom 上。")])])]),t._v(" "),e("h3",{attrs:{id:"vue-筛选器过滤多个参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-筛选器过滤多个参数"}},[t._v("#")]),t._v(" vue 筛选器过滤多个参数")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("filter 支持函数 message | 方法 A('arg1', arg2)\n"),e("ul",[e("li",[t._v("方法 A 被定义为接收三个参数的过滤器函数。")]),t._v(" "),e("li",[t._v("message 的值作为第一个参数")]),t._v(" "),e("li",[t._v("表达式 'arg1' 作为第二个参数")]),t._v(" "),e("li",[t._v("表达式 arg2 的值作为第三个参数。")])])]),t._v(" "),e("li",[t._v("filter 支持多次过滤")])])]),t._v(" "),e("h3",{attrs:{id:"严格模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[t._v("#")]),t._v(" 严格模式")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("严格模式是采用具有限制性 JavaScript 变体的一种方式，从而使代码脱离马虎模式/稀松模式/懒散模式模式。")]),t._v(" "),e("ul",[e("li",[t._v("严格模式通过抛出错误来消除了一些原有静默错误")]),t._v(" "),e("li",[t._v("严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快")]),t._v(" "),e("li",[t._v("严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 整个脚本都开启严格模式的语法\n"use strict";\n1，全局变量的显示声明\n2，严格模式限制了动态绑定，比如禁止使用with,创设eval的单独作用域\n3，严格模式下让你头痛的this关键字不能指向全局变量了\n4，不能重名：对象不能有重名属性，方法不能有重名形参\n5，对于arguments的限制，严格模式下不能对其赋值了，也不再跟踪参数的变化，arguments.callee也不允许使用\n6，函数必须声明在顶层，不允许在非函数代码块内声明函数\n7，试图删除不可删除的属性时会抛出异常\n8，严格模式禁止八进制数字语法\n9，ECMAScript 6中的严格模式禁止设置primitive值的属性\n10，在严格模式中一部分字符变成了保留的关键字\n')])])])]),t._v(" "),e("h3",{attrs:{id:"冒泡排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[t._v("#")]),t._v(" 冒泡排序")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/catalog_base/algorithm/#冒泡排序",title:"算法"}},[t._v("算法")])],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);